<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Menu Matching Game</title>
    <style>
      /* Neo-Brutalist Base styles inspired by NeoBrutalismCSS */
      :root {
        /* Light theme variables */
        --bg-primary: #833ab4;
        --bg-gradient: linear-gradient(
          67deg,
          rgba(131, 58, 180, 1) 0%,
          rgba(253, 62, 38, 1) 59%,
          rgba(252, 176, 69, 1) 100%
        );
        --text-primary: #000000;
        --text-secondary: #333333;
        --card-bg: #ffffff;
        --border-color: #000000;
        --shadow-color: #000000;
        --accent-orange: #ff6b35;
        --accent-teal: #4ecdc4;
        --menu-header-bg: #ff6b35;
        --menu-header-text: #ffffff;
        --border-radius: 0px;
      }

      [data-theme="dark"] {
        /* Dark theme variables */
        --bg-primary: #0f0f0f;
        --bg-gradient: linear-gradient(
          67deg,
          #0f0f0f 0%,
          #1a1a2e 25%,
          #16213e 50%,
          #0f3460 75%,
          #0f0f0f 100%
        );
        --text-primary: #ffffff;
        --text-secondary: #b0b0b0;
        --card-bg: #1a1a1a;
        --border-color: white;
        --shadow-color: #000000;
        --accent-orange: #ff6b35;
        --accent-teal: #4ecdc4;
        --menu-header-bg: #ff6b35;
        --menu-header-text: #ffffff;
      }

      body {
        font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI",
          Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue",
          sans-serif;
        margin: 0;
        padding: 0;
        background: var(--bg-primary);
        background: var(--bg-gradient);
        color: var(--text-primary);
        line-height: 1.4;
        min-height: 100vh;
        transition: all 0.3s ease;
      }

      .game-container {
        max-width: 800px;
        margin: 0 auto;
        padding: 2rem;
        background: transparent;
      }

      h1 {
        color: var(--text-primary);
        margin-bottom: 1rem;
        text-transform: uppercase;
        letter-spacing: 2px;
        font-weight: 900;
        font-size: 3rem;
        text-align: center;
        text-shadow: 4px 4px 0px var(--accent-teal);
      }

      .game-mode-toggle {
        text-align: center;
        margin-bottom: 2rem;
      }

      .score {
        font-size: 1.5rem;
        margin-bottom: 2rem;
        color: var(--text-primary);
        text-align: center;
        background: var(--accent-orange);
        padding: 1rem 2rem;
        border: 3px solid var(--border-color);
        box-shadow: 5px 5px 0px var(--shadow-color);
        text-transform: uppercase;
        font-weight: bold;
        display: inline-block;
        margin: 0 1rem 2rem auto;
      }

      .image-container {
        margin: 2rem 0;
        text-align: center;
      }

      .food-image {
        max-width: 400px;
        max-height: 300px;
        border: 4px solid var(--border-color);
        box-shadow: 8px 8px 0px var(--accent-orange);
        transition: all 0.3s ease;
      }

      .food-image:hover {
        transform: rotate(0deg) translateY(-8px);
        box-shadow: 12px 12px 0px var(--accent-teal);
      }

      .images-container {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 1.5rem;
        margin: 2rem 0;
      }

      .image-option {
        cursor: pointer;
        border: 4px solid var(--border-color);
        background: var(--card-bg);
        box-shadow: 8px 8px 0px var(--accent-orange);
        transform: rotate(-1deg);
        transition: all 0.3s ease;
        overflow: hidden;
      }

      .image-option:hover {
        transform: rotate(0deg) translateY(-8px);
        box-shadow: 12px 12px 0px var(--accent-teal);
      }

      .image-option img {
        width: 100%;
        height: 200px;
        object-fit: cover;
        display: block;
      }

      .image-option.correct {
        border-color: var(--accent-teal);
        background: var(--accent-teal);
        box-shadow: 8px 8px 0px var(--shadow-color);
        transform: rotate(0deg);
      }

      .image-option.incorrect {
        border-color: var(--accent-orange);
        background: var(--accent-orange);
        box-shadow: 8px 8px 0px var(--shadow-color);
        transform: rotate(0deg);
      }

      .image-option.disabled {
        cursor: not-allowed;
        opacity: 0.7;
      }

      .food-name {
        font-size: 2rem;
        font-weight: 900;
        color: var(--text-primary);
        text-align: center;
        background: var(--accent-teal);
        padding: 1rem 2rem;
        border: 4px solid var(--border-color);
        box-shadow: 6px 6px 0px var(--shadow-color);
        text-transform: uppercase;
        letter-spacing: 2px;
        transform: rotate(-1deg);
        margin: 2rem auto;
        display: inline-block;
      }

      .options-container {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 1.5rem;
        margin: 2rem 0;
      }

      .option-button {
        padding: 1.5rem 2rem;
        border: 4px solid var(--border-color);
        background: var(--card-bg);
        cursor: pointer;
        font-size: 1.2rem;
        font-weight: 900;
        text-transform: uppercase;
        letter-spacing: 1px;
        transition: all 0.3s ease;
        box-shadow: 8px 8px 0px var(--accent-orange);
        color: var(--text-primary);
      }

      .option-button:hover {
        transform: rotate(0deg) translateY(-8px);
        box-shadow: 12px 12px 0px var(--accent-teal);
        background: var(--accent-teal);
      }

      .option-button.correct {
        border-color: var(--accent-teal);
        background: var(--accent-teal);
        color: var(--text-primary);
        box-shadow: 8px 8px 0px var(--shadow-color);
        transform: rotate(0deg);
      }

      .option-button.incorrect {
        border-color: var(--accent-orange);
        background: var(--accent-orange);
        color: var(--text-primary);
        box-shadow: 8px 8px 0px var(--shadow-color);
        transform: rotate(0deg);
      }

      .option-button.disabled {
        cursor: not-allowed;
        opacity: 0.7;
      }

      .message {
        margin: 2rem 0;
        padding: 1.5rem;
        border: 4px solid var(--border-color);
        font-weight: 900;
        text-transform: uppercase;
        letter-spacing: 1px;
        font-size: 1.2rem;
        text-align: center;
        box-shadow: 6px 6px 0px var(--shadow-color);
        transform: rotate(-1deg);
      }

      .message.correct {
        background: var(--accent-teal);
        color: var(--text-primary);
        border-color: var(--accent-teal);
      }

      .message.incorrect {
        background: var(--accent-orange);
        color: var(--text-primary);
        border-color: var(--accent-orange);
      }

      .next-button {
        background: var(--accent-teal);
        color: var(--text-primary);
        border: 4px solid var(--border-color);
        padding: 1rem 2rem;
        border-radius: var(--border-radius);
        font-size: 1.2rem;
        cursor: pointer;
        margin-top: 2rem;
        font-weight: 900;
        text-transform: uppercase;
        letter-spacing: 1px;
        box-shadow: 6px 6px 0px var(--accent-orange);
        transform: rotate(-1deg);
        transition: all 0.3s ease;
      }

      .next-button:hover {
        transform: rotate(0deg) translateY(-4px);
        box-shadow: 8px 8px 0px var(--accent-orange);
        background: var(--accent-orange);
      }

      .game-over {
        font-size: 3rem;
        font-weight: 900;
        color: var(--text-primary);
        margin: 2rem 0;
        text-transform: uppercase;
        letter-spacing: 3px;
        text-shadow: 4px 4px 0px var(--shadow-color);
        text-align: center;
      }

      .final-score {
        font-size: 2rem;
        color: var(--text-primary);
        text-align: center;
        background: var(--accent-orange);
        padding: 1rem 2rem;
        border: 4px solid var(--border-color);
        box-shadow: 6px 6px 0px var(--shadow-color);
        text-transform: uppercase;
        font-weight: bold;
        transform: rotate(-1deg);
        display: inline-block;
        margin: 1rem auto;
      }

      .restart-button {
        background: var(--accent-teal);
        color: var(--text-primary);
        border: 4px solid var(--border-color);
        padding: 1rem 2rem;
        border-radius: var(--border-radius);
        font-size: 1.2rem;
        cursor: pointer;
        margin-top: 2rem;
        font-weight: 900;
        text-transform: uppercase;
        letter-spacing: 1px;
        box-shadow: 6px 6px 0px var(--accent-orange);
        transform: rotate(-1deg);
        transition: all 0.3s ease;
      }

      .restart-button:hover {
        transform: rotate(0deg) translateY(-4px);
        box-shadow: 8px 8px 0px var(--accent-orange);
        background: var(--accent-orange);
      }

      /* Neo-Brutalist Animation */
      @keyframes brutalFadeIn {
        from {
          opacity: 0;
          transform: translateY(40px) rotate(-5deg);
        }
        to {
          opacity: 1;
          transform: translateY(0) rotate(0deg);
        }
      }

      .game-container {
        animation: brutalFadeIn 0.6s ease forwards;
      }

      /* Username Modal Styles */
      .username-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
      }
      .username-modal-box {
        background: #fff;
        padding: 2rem;
        border-radius: 8px;
        box-shadow: 0 4px 24px rgba(0, 0, 0, 0.2);
        text-align: center;
      }
      .username-modal-label {
        display: block;
        margin-bottom: 1rem;
      }
      .username-modal-input {
        font-size: 1.2rem;
        padding: 0.5rem;
        margin-bottom: 1rem;
        width: 80%;
      }
      .username-modal-error {
        color: red;
        margin-bottom: 1rem;
      }
      .username-modal-button {
        font-size: 1.2rem;
        padding: 0.5rem 2rem;
        background: #4ecdc4;
        color: #000;
        border: none;
        cursor: pointer;
        font-weight: bold;
      }
      .user-name {
        color: var(--text-primary);
        position: absolute;
        top: 1rem;
      }

      /* Responsive adjustments */
      @media (max-width: 768px) {
        .game-container {
          padding: 1rem;
        }

        h1 {
          font-size: 2rem;
        }

        .options-container,
        .images-container {
          grid-template-columns: 1fr;
        }

        .food-image {
          max-width: 100%;
        }

        .option-button {
          font-size: 1rem;
          padding: 1rem 1.5rem;
        }
      }
    </style>
  </head>
  <body>
    <div class="game-container">
      <h1>Menu Matching Game</h1>

      <div class="score">Score: <span id="score">0</span></div>
      <div class="score" id="timer" style="display: none">
        Time: <span id="time-left">20</span>s
      </div>

      <div id="game-area">
        <!-- Image to Name Mode -->
        <div id="image-to-name-mode">
          <div class="image-container">
            <img id="food-image" class="food-image" src="" alt="Food item" />
          </div>

          <div class="options-container" id="options-container">
            <!-- Options will be populated here -->
          </div>
        </div>

        <!-- Name to Image Mode -->
        <div id="name-to-image-mode" style="display: none">
          <div class="food-name" id="food-name">
            <!-- Food name will be populated here -->
          </div>

          <div class="images-container" id="images-container">
            <!-- Image options will be populated here -->
          </div>
        </div>

        <div id="message" class="message" style="display: none"></div>

        <button id="next-button" class="next-button" style="display: none">
          Next Round
        </button>
      </div>

      <div id="game-over" style="display: none">
        <div class="game-over">Game Over!</div>
        <div class="final-score">
          Final Score: <span id="final-score">0</span>
        </div>
        <button class="restart-button" onclick="startGame()">Play Again</button>
      </div>
    </div>

    <script type="module">
      let menuItems = [];
      let currentRound = null;
      let roundMeta = { roundId: null, mode: "image-to-name" };
      let timerInterval = null;
      const ROUND_SECONDS = 20;
      let score = 0;
      let userName = "Guest";
      // Fetch score from backend
      const fetchScore = async () => {
        try {
          const res = await fetch("/score", { credentials: "include" });
          const data = await res.json();
          score = data.score || 0;
          userName = data.userName || "Guest";
          updateScore();
          if (userName === "Guest") {
            promptForUserName();
          }
        } catch (e) {
          score = 0;
          userName = "Guest";
          updateScore();
        }
      };
      let gameActive = false;
      let currentMode = "image-to-name";
      let usedItems = new Set(); // Track used items to avoid repetition

      // Pure function to shuffle array
      const shuffleArray = (array) => {
        const shuffled = [...array];
        for (let i = shuffled.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }
        return shuffled;
      };

      // Pure function to get random items
      const getRandomItems = (items, count) => {
        const shuffled = shuffleArray(items);
        return shuffled.slice(0, count);
      };

      // Pure function to get random item with image
      const getRandomItemWithImage = (items) => {
        const itemsWithImages = items.filter((item) => item.imageurl);
        if (itemsWithImages.length === 0) return null;

        // Filter out already used items
        const availableItems = itemsWithImages.filter(
          (item) => !usedItems.has(item.name)
        );

        // If no available items, reset used items and start over
        if (availableItems.length === 0) {
          usedItems.clear();
          return itemsWithImages[
            Math.floor(Math.random() * itemsWithImages.length)
          ];
        }

        const randomIndex = Math.floor(Math.random() * availableItems.length);
        return availableItems[randomIndex];
      };

      // Options are now server-authoritative

      // Pure function to randomly select game mode
      const getRandomMode = () => {
        const modes = ["image-to-name", "name-to-image"];
        const randomIndex = Math.floor(Math.random() * modes.length);
        return modes[randomIndex];
      };

      // Save game state to localStorage
      const saveGameState = () => {
        const gameState = {
          score,
          gameActive,
          currentMode,
          usedItems: Array.from(usedItems),
          timestamp: Date.now(),
        };
        localStorage.setItem("menuGameState", JSON.stringify(gameState));
      };

      // Load game state from localStorage
      const loadGameState = () => {
        try {
          const savedState = localStorage.getItem("menuGameState");
          if (savedState) {
            const gameState = JSON.parse(savedState);

            // Check if saved state is from today (within 24 hours)
            const isToday =
              Date.now() - gameState.timestamp < 24 * 60 * 60 * 1000;

            if (isToday) {
              score = gameState.score || 0;
              gameActive = gameState.gameActive || false;
              currentMode = gameState.currentMode || "image-to-name";
              usedItems = new Set(gameState.usedItems || []);
              return true;
            } else {
              // Clear old state if it's from a previous day
              localStorage.removeItem("menuGameState");
            }
          }
        } catch (error) {
          console.error("Error loading game state:", error);
          localStorage.removeItem("menuGameState");
        }
        return false;
      };

      // Clear game state from localStorage
      const clearGameState = () => {
        localStorage.removeItem("menuGameState");
      };

      const updateScore = () => {
        document.getElementById("score").textContent = score;
      };

      // Make options move away from the mouse cursor on desktop to make clicking harder
      const isFinePointer = () =>
        typeof window !== "undefined" &&
        window.matchMedia &&
        window.matchMedia("(pointer: fine)").matches;

      const evadePointer = (element) => {
        if (!isFinePointer()) return;
        if (!gameActive) return;
        if (element.classList.contains("disabled")) return;
        if (element.dataset.evadeCooldown === "1") return;

        const maxOffset = 60;
        const dx = (Math.random() * 2 - 1) * maxOffset;
        const dy = (Math.random() * 2 - 1) * maxOffset;
        const rotate = (Math.random() * 2 - 1) * 8;
        element.style.transform = `translate(${dx}px, ${dy}px) rotate(${rotate}deg)`;
        element.dataset.evadeCooldown = "1";
        setTimeout(() => {
          element.dataset.evadeCooldown = "0";
        }, 180);
      };

      const startTimer = (expiresAtMs) => {
        const timerBox = document.getElementById("timer");
        const timeLeft = document.getElementById("time-left");
        timerBox.style.display = "inline-block";
        clearInterval(timerInterval);
        const update = () => {
          const remainingMs = Math.max(0, expiresAtMs - Date.now());
          const secs = Math.ceil(remainingMs / 1000);
          timeLeft.textContent = String(secs);
          if (remainingMs <= 0) {
            clearInterval(timerInterval);
            // Auto-submit no selection to count as wrong
            if (roundMeta.roundId) {
              handleTimeout();
            }
          }
        };
        update();
        timerInterval = setInterval(update, 200);
      };

      const stopTimer = () => {
        clearInterval(timerInterval);
        document.getElementById("timer").style.display = "none";
      };

      const promptForUserName = () => {
        if (document.getElementById("username-modal")) return;
        const modal = document.createElement("div");
        modal.id = "username-modal";
        modal.className = "username-modal";

        const box = document.createElement("div");
        box.className = "username-modal-box";

        const label = document.createElement("label");
        label.textContent = "Enter your username:";
        label.className = "username-modal-label";

        const input = document.createElement("input");
        input.type = "text";
        input.maxLength = 32;
        input.minLength = 2;
        input.className = "username-modal-input";

        const error = document.createElement("div");
        error.className = "username-modal-error";

        const button = document.createElement("button");
        button.textContent = "Save";
        button.className = "username-modal-button";
        button.onclick = async () => {
          const val = input.value.trim();
          const allowed = /^[\p{L}\p{N} _'’\-.]{2,22}$/u;
          if (!allowed.test(val)) {
            error.textContent =
              "2-22 chars. Letters, numbers, spaces, _-' . only.";
            return;
          }
          button.disabled = true;
          try {
            const res = await fetch("/user/name", {
              method: "POST",
              credentials: "include",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ userName: val }),
            });
            const data = await res.json();
            if (data.success) {
              userName = val;
              document.body.removeChild(modal);
            } else {
              error.textContent = data.error || "Failed to save username.";
              button.disabled = false;
            }
          } catch (e) {
            button.disabled = false;
          }
        };

        box.appendChild(label);
        box.appendChild(input);
        box.appendChild(error);
        box.appendChild(button);
        modal.appendChild(box);
        document.body.appendChild(modal);
      };

      const showMessage = (text, isCorrect) => {
        const messageEl = document.getElementById("message");
        messageEl.textContent = text;
        messageEl.className = `message ${isCorrect ? "correct" : "incorrect"}`;
        messageEl.style.display = "block";
      };

      const hideMessage = () => {
        document.getElementById("message").style.display = "none";
      };

      const disableOptions = () => {
        if (currentMode === "image-to-name") {
          const buttons = document.querySelectorAll(".option-button");
          buttons.forEach((button) => {
            button.classList.add("disabled");
            button.style.pointerEvents = "none";
          });
        } else {
          const images = document.querySelectorAll(".image-option");
          images.forEach((image) => {
            image.classList.add("disabled");
            image.style.pointerEvents = "none";
          });
        }
      };

      const enableOptions = () => {
        if (currentMode === "image-to-name") {
          const buttons = document.querySelectorAll(".option-button");
          buttons.forEach((button) => {
            button.classList.remove("disabled");
            button.style.pointerEvents = "auto";
          });
        } else {
          const images = document.querySelectorAll(".image-option");
          images.forEach((image) => {
            image.classList.remove("disabled");
            image.style.pointerEvents = "auto";
          });
        }
      };

      const clearOptionStyles = () => {
        if (currentMode === "image-to-name") {
          const buttons = document.querySelectorAll(".option-button");
          buttons.forEach((button) => {
            button.classList.remove("correct", "incorrect");
            button.style.transform = "";
          });
        } else {
          const images = document.querySelectorAll(".image-option");
          images.forEach((image) => {
            image.classList.remove("correct", "incorrect");
            image.style.transform = "";
          });
        }
      };

      const createNewRound = async () => {
        // Ask server for next round
        const res = await fetch("/game/next", {
          method: "POST",
          credentials: "include",
        });
        const data = await res.json();
        if (data?.error && data.error.includes("Active round")) {
          // If server says active round exists, do nothing until answer
          return;
        }
        renderRound(data);
      };

      const createImageToNameRound = (payload) => {
        roundMeta = { roundId: payload.roundId, mode: payload.mode };
        currentMode = payload.mode;

        document.getElementById("image-to-name-mode").style.display = "block";
        document.getElementById("name-to-image-mode").style.display = "none";

        hideMessage();
        clearOptionStyles();
        enableOptions();
        document.getElementById("next-button").style.display = "none";

        const imageEl = document.getElementById("food-image");
        imageEl.src = payload.image;

        const optionsContainer = document.getElementById("options-container");
        optionsContainer.innerHTML = "";
        payload.options.forEach((opt) => {
          const button = document.createElement("button");
          button.className = "option-button";
          button.textContent = opt.label;
          button.onclick = () => handleOptionClick(opt.id, button);
          // Evade mouse on hover/move (desktop only)
          button.addEventListener("mouseenter", () => evadePointer(button), {
            passive: true,
          });
          button.addEventListener("mousemove", () => evadePointer(button), {
            passive: true,
          });
          optionsContainer.appendChild(button);
        });
        startTimer(payload.expiresAtMs);
      };

      const createNameToImageRound = (payload) => {
        roundMeta = { roundId: payload.roundId, mode: payload.mode };
        currentMode = payload.mode;

        document.getElementById("image-to-name-mode").style.display = "none";
        document.getElementById("name-to-image-mode").style.display = "block";

        hideMessage();
        clearOptionStyles();
        enableOptions();
        document.getElementById("next-button").style.display = "none";

        const nameEl = document.getElementById("food-name");
        nameEl.textContent = payload.prompt;

        const imagesContainer = document.getElementById("images-container");
        imagesContainer.innerHTML = "";
        payload.options.forEach((opt) => {
          const imageDiv = document.createElement("div");
          imageDiv.className = "image-option";
          imageDiv.onclick = () => handleImageClick(opt.id, imageDiv);
          const img = document.createElement("img");
          img.src = opt.imageurl;
          img.alt = opt.alt;
          imageDiv.appendChild(img);
          // Evade mouse on hover/move (desktop only)
          imageDiv.addEventListener(
            "mouseenter",
            () => evadePointer(imageDiv),
            {
              passive: true,
            }
          );
          imageDiv.addEventListener("mousemove", () => evadePointer(imageDiv), {
            passive: true,
          });
          imagesContainer.appendChild(imageDiv);
        });
        startTimer(payload.expiresAtMs);
      };

      const handleOptionClick = async (optionId, element) => {
        if (!gameActive) return;

        const res = await fetch("/game/answer", {
          method: "POST",
          credentials: "include",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ roundId: roundMeta.roundId, optionId }),
        });
        const data = await res.json();
        await fetchScore();

        stopTimer();
        if (data.correct) {
          element.classList.add("correct");
          showMessage("Correct! Well done!", true);
        } else {
          element.classList.add("incorrect");
          showMessage("Wrong! Back to 0 points.", false);
        }
        disableOptions();
        document.getElementById("next-button").style.display = "inline-block";
      };

      const handleImageClick = async (optionId, element) => {
        if (!gameActive) return;

        const res = await fetch("/game/answer", {
          method: "POST",
          credentials: "include",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ roundId: roundMeta.roundId, optionId }),
        });
        const data = await res.json();
        await fetchScore();

        stopTimer();
        if (data.correct) {
          element.classList.add("correct");
          showMessage("Correct! Well done!", true);
        } else {
          element.classList.add("incorrect");
          showMessage("Wrong! Back to 0 points.", false);
        }
        disableOptions();
        document.getElementById("next-button").style.display = "inline-block";
      };

      const nextRound = () => {
        createNewRound();
      };

      const endGame = async () => {
        gameActive = false;
        document.getElementById("game-area").style.display = "none";
        await fetchScore();
        document.getElementById("final-score").textContent = score;
        document.getElementById("game-over").style.display = "block";
      };

      const startGame = async () => {
        gameActive = true;
        usedItems.clear(); // Reset used items for new game
        await fetchScore();
        document.getElementById("game-area").style.display = "block";
        document.getElementById("game-over").style.display = "none";
        // Request a fresh server round
        const res = await fetch("/game/start", {
          method: "POST",
          credentials: "include",
        });
        const data = await res.json();
        renderRound(data);
      };

      const renderRound = (payload) => {
        if (!payload || payload.error) return;
        if (payload.mode === "image-to-name") {
          createImageToNameRound(payload);
        } else {
          createNameToImageRound(payload);
        }
      };

      const handleTimeout = async () => {
        // Submit with no optionId is invalid; choose a non-existent id to ensure wrong
        const fakeId = "__timeout__";
        const res = await fetch("/game/answer", {
          method: "POST",
          credentials: "include",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            roundId: roundMeta.roundId,
            optionId: fakeId,
          }),
        });
        await fetchScore();
        showMessage("Time's up! Score reset to 0.", false);
        disableOptions();
        document.getElementById("next-button").style.display = "inline-block";
      };

      // Initialize game
      const initGame = async () => {
        try {
          await startGame();
        } catch (error) {
          console.error("Failed to load menu items:", error);
          document.querySelector(".game-container").innerHTML =
            "<h1>Error</h1><p>Failed to load menu items. Please try again.</p>";
        }
      };

      // Set up event listeners
      document.getElementById("next-button").onclick = nextRound;

      // Start the game when page loads
      initGame();
    </script>
  </body>
</html>
